#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
"""Provides the event handlers and outputs for the GUI """
#   (c)2019 Jeff Chamberlain
# This program is free software: you can use it under the terms of the
# GNU Affero General Public License version 3. This program is distributed
# WITHOUT ANY WARRANTY of any kind. See the GNU Affero General Public License
# for more details. <https://www.gnu.org/licenses/>.

# Support module generated by PAGE version 4.22 in conjunction with Tcl v8.6

from os import getcwd, system
from tkinter import IntVar, StringVar
from tkinter.messagebox import askyesno
import SimpleAbout

global ALPHA       # The fine structure constant Î± is 1/137.036...
ALPHA = 137.036    # Values are set to this to indicate that an error occurred.


def set_Tk_var():
    global focal_select
    focal_select = IntVar()
    global object_select
    object_select = IntVar()
    global image_select
    image_select = IntVar()
    global magnification_select
    magnification_select = IntVar()
    global focal_text
    focal_text = StringVar()
    global object_text
    object_text = StringVar()
    global image_text
    image_text = StringVar()
    global magnification_text
    magnification_text = StringVar()
    global radio
    radio = StringVar()
    global message
    message = StringVar()
    global sig_figs
    sig_figs = StringVar()


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top


def UserTyped(event):
    """ Handle keyboard input.

    Exceptions to this are handled in the KeyPressed function. Only digits
    and +,-,e,.,: allowed. Digits call Calculate.
    """
    key_in = event.char
    if key_in == ",":
        key_in = ":"
    if key_in in "0123456789+-.e:" and key_in != "":
        if event.widget.selection_present():
            event.widget.delete('sel.first', 'sel.last')
        event.widget.insert('insert', key_in)
        if key_in in "0123456789":
            Calculate()


def KeyPressed(event):
    """Handle Enter, BackSpace, and Delete keys."""
    sym = event.keysym
    if event.widget.selection_present():
        if sym == "Delete" or sym == "BackSpace":
            event.widget.delete('sel.first', 'sel.last')
    else:
        if sym == "Delete":
            event.widget.delete('insert')
        if sym == "BackSpace":
            event.widget.insert('insert', "x")  # Wrote kludge because the
            a = event.widget.get()              # insertion point could not be
            x = a.find("x")                     # found. So, add an "x" and
            x -= 1                              # delete two characters.
            event.widget.delete(x)
            event.widget.delete(x)
    Calculate()


def WhatKnow():
    """Read checkboxes for variables to hold constant."""
    known = [focal_select.get(), object_select.get(),
             image_select.get(), magnification_select.get()]
    return known


def Calculate():
    """Call functions to complete the whole calculation cycle."""
    values = GetValues()
    values = SolveEqn(values)
    DisplayValues(values)


def GetValues():
    """Read the entry box strings, call SafeFloat on them, return as a list."""
#    f = SafeFloat(w.focal_entry.get())
#    so = SafeFloat(w.object_entry.get())
#    si = SafeFloat(w.image_entry.get())
#    m = SafeFloat(w.magnification_entry.get())
#    return [f, so, si, m]
    svalues = GetStrings()
    values = [0, 0, 0, 0]
    for i in range(4):
        values[i] = SafeFloat(svalues[i])
    return values


def GetStrings():
    """Read the entry box strings and return as a list."""
    f = w.focal_entry.get()
    so = w.object_entry.get()
    si = w.image_entry.get()
    m = w.magnification_entry.get()
    return [f, so, si, m]


def SolveEqn(values):
    """Take list of values, calcualte unknowns from knowns, return solution"""
    known = WhatKnow()
    valstr = GetStrings()
    err = ""
    if known.count(1) != 2:
        known = [0, 0, 0, 0]
        err = "Number Of Knowns Is Not 2"
    for k in range(4):
        values[k] = round(values[k], 9)    # Prevent funny float behavior
        if (known[k] and (values[k] == 0)):    # No zeroes allowed.+
            values[k] = ALPHA
            if ":" in valstr[k]:    # Leave entries alone if there's a :
                err = " "
            else:
                names = ["Focal Length", "Object Distance",
                         "Image Distance", "Magnification"]
                err = names[k] + " Cannot Be Zero"
    f, so, si, m = values
    if ((known[1] and known[2]) and (so == -si)):
        values[1] = ALPHA
        values[2] = ALPHA
        err = "Object and Image Positions Cannot Be The Same"
    if ((known[1] and known[0]) and (f == so)):
        values[0] = ALPHA
        values[1] = ALPHA
        err = "Object Cannot Be At Focal Point"
    if ((known[2] and known[0]) and (f == si)):
        values[0] = ALPHA
        values[2] = ALPHA
        err = "Image Cannot Be At Focal Point"
    if ((known[3]) and (m == 1)):
        values[3] = ALPHA
        err = "Magnification Cannot Be One"
    if not err:
        if known[1] and known[2]:
            f = so*si/(so+si)
            m = -1*si/so
        elif known[1] and known[0]:
            si = f*so/(so-f)
            m = f/(f-so)
        elif known[2] and known[0]:
            so = f*si/(si-f)
            m = (f-si)/f
        elif known[1] and known[3]:
            si = -1*m*so
            f = m*so/(m-1)
        elif known[2] and known[3]:
            f = si/(1-m)
            so = -1*si/m
        elif known[3] and known[0]:
            si = (1-m)*f
            so = f/m*(m-1)
        send_message("---")
        return [f, so, si, m]
    else:
        send_message(err, "red")
        return values


def SafeFloat(a):
    """Since float can't handle non-digits, do it the right way."""
    try:
        a = float(a)
    except ValueError:
        a = 0.0
    return a


def DisplayValues(values, sigfigs=4):
    """Round values to <sigfigs> sig. figs. and display the values."""
    if ALPHA not in values:
        valstr = ["", "", "", ""]
        for i in range(4):
            valstr[i] = ("{:0." + str(sigfigs) + "}").format(values[i])
            valstr[i] = valstr[i].rstrip("0").rstrip(".")
        SendStr(valstr)
        if values[2] > 0:
            adj = "real"
        else:
            adj = "virtual"
        if values[3] > 0:
            adj = adj + ", upright"
        else:
            adj = adj + ", inverted"
        if abs(values[3]) > 1:
            adj = adj + ", enlarged"
        elif abs(values[3]) < 1:
            adj = adj + ", reduced"
        else:
            adj = adj + ", same size"
        if values[1] < 0:
            adj = adj + ", with virtual object"
        send_message(adj)


def SendStr(valstr):
    """Take string of values and put them into the entry boxes."""
    f, so, si, m = valstr
    focal_text.set(f)
    object_text.set(so)
    image_text.set(si)
    magnification_text.set(m)


def GenerateList():
    """Make a list of values for a range of input values

    ind -- is which entry has the radio button set to have a range of values
            0 for f, 1 for so, 2 for si, 3 for m
    """
    base_name = str(radio.get())    # Determine ind
    marked = [(base_name == "focal"), (base_name == "object"),
              (base_name == "image"), (base_name == "magnification")]
    ind = marked.index(True)
    known = WhatKnow()    # Make sure ind is set as a known
    if known[ind] == 0:
        send_message("Variable Value Not A Known", "red")
        return
    entries = GetStrings()    # Resolve entry as start:end:step.
    range_str = entries[ind]
    range_bits = range_str.split(":")
    if len(range_bits) < 2:
        send_message("Range Not Defined", "red")
        return
    start = SafeFloat(range_bits[0])
    end = SafeFloat(range_bits[1])
    if start > end:
        step = start
        start = end
        end = step + 1e-7
    if len(range_bits) == 3:
        step = abs(SafeFloat(range_bits[2]))
    else:
        step = 1.0
    numval = int((end - start) / step)
    if numval > 1000:
        warn = ("About " + str(numval) + " entries will be generated.\n" +
                "Continue?")
        if askyesno("Continue?", warn) is False:
            return
    val = start    # Initialize values before while loop.
    dvalues = GetValues()
    dvalues[ind] = val
    badval = 0
    numval = 0
    sigfigs_str = sig_figs.get()
    if sigfigs_str not in "3456":
        send_message("Please Use 3 to 6 Significant Figures", "red")
        return
    sigfigs = int(sigfigs_str)

    while val < end:    # Loop values and store results in DataTree
        numval += 1
        dvalues = GetValues()
        dvalues[ind] = val
        svalues = SolveEqn(dvalues)
        DisplayValues(svalues, sigfigs)
        entries = GetStrings()
        if ALPHA in svalues:
            badval += 1
            entries[ind] = ("{:0." + str(sigfigs) + "}").format(
                            val).rstrip("0").rstrip(".")
            for v in range(4):
                if known[v] == 0:
                    entries[v] = "---"
        for v in range(4):
            entries[v] = "{:^22}".format(entries[v])
        w.DataTree.insert("", 'end', values=entries)
        val = val + step
    dvalues[ind] = start    # Restore known entries to initial values and
    svalues = SolveEqn(dvalues)    # evaluate unknowns with start value.
    DisplayValues(svalues)
    entries = GetStrings()
    entries[ind] = range_str
    SendStr(entries)
    msg = "Generated " + str(numval) + " Entries"
    if badval:
        msg = msg + " with " + str(badval) + " Unusable Value(s)"
    send_message(msg)


def clear_table():
    """Delete all entries in DataTree."""
    ids = w.DataTree.get_children()
    for iid in ids:
        w.DataTree.delete(iid)
    send_message("---")


def reset_entries():
    """Set default state to f=known=10, so=known=12, radio=so, sigfigs=3."""
    radio.set("object")
    w.focal_check.select()
    w.object_check.select()
    w.image_check.deselect()
    w.magnification_check.deselect()
    focal_text.set("10")
    object_text.set("12")
    sig_figs.set("3")
    Calculate()


def list_demo():
    """Demonstrate a list generating entry."""
    reset_entries()
    focal_text.set("15")
    object_text.set("22:25:0.3")
    GenerateList()
    send_message("Values of s\u2080 from 22 to under 25" +
                 " in increments of 0.3")


def reset_all():
    clear_table()
    reset_entries()


def TreeClick(p1):
    GenerateList()


def ShowAbout():
    send_message("Lens Problem Designer by Jeff Chamberlain", "blue")
    SimpleAbout.create_About(root)


def ShowHelp():
    helpfile = getcwd()+"\\LPDHelpfiles\\LPDHelp.html"
    cmd = "start " + helpfile
    system(cmd)


def OnExitMenu():
    destroy_window()


def send_message(msg, color="black"):
    """Send string msg to label message_label and set color. Color options
        are "blue" and "red", all others default to black."""
    if color == "blue":
        fground = "#0000f0"
    elif color == "red":
        fground = "#ff2659"
    else:
        fground = "#000000"
    w.message_label.configure(foreground=fground)
    message.set(msg)


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None
